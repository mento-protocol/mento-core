// SPDX-License-Identifier: GPL-3.0-or-later
// solhint-disable func-name-mixedcase, var-name-mixedcase, state-visibility
pragma solidity ^0.8;

import { IFPMMCallee } from "contracts/interfaces/IFPMMCallee.sol";
import { FPMM } from "contracts/swap/FPMM.sol";
import { IERC20 } from "openzeppelin-contracts-next/contracts/token/ERC20/IERC20.sol";

contract ReentrancyExploiter is IFPMMCallee {
  FPMM public fpmm;
  address public token0;
  address public token1;
  bool public isReentering;

  constructor(address _fpmm, address _token0, address _token1) {
    fpmm = FPMM(_fpmm);
    token0 = _token0;
    token1 = _token1;
  }

  function executeFlashLoanAttack(uint256 amount0, uint256 amount1) external {
    isReentering = false;
    fpmm.swap(amount0, amount1, address(this), "Reentrancy attack");
  }

  function hook(address, uint256 amount0, uint256 amount1, bytes calldata) external override {
    require(msg.sender == address(fpmm), "Not called by FPMM");

    if (!isReentering) {
      isReentering = true;

      // Try to reenter the swap function while in the middle of a swap
      fpmm.swap(10e18, 0, address(this), "Reentrancy attempt");
    }

    // Repay the flash loan to avoid other errors
    if (amount0 > 0) {
      IERC20(token0).transfer(address(fpmm), amount0);
    }
    if (amount1 > 0) {
      IERC20(token1).transfer(address(fpmm), amount1);
    }
  }
}
